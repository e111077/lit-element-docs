export const readmes = {"xarrays":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xbasicproperties":"<p>In your element class: </p>\n<ul>\n<li>Declare property names and types in a static <code>properties</code> getter.</li>\n<li>Initialize property values in the element constructor.</li>\n<li>Pass the properties used in the element's template to the <code>_render</code> function.</li>\n</ul>\n<p>In HTML: </p>\n<ul>\n<li>Supply property values in markup, <strong>or</strong></li>\n<li>Omit properties from markup, and use the defaults set in the constructor.</li>\n</ul>\n<p><strong>custom-element.js</strong></p>\n<pre><code class=\"js language-js\">// Declare property names and types.\nstatic get properties(){\n  return {\n    adjective: String,\n    level: Number\n  };\n}\n\nconstructor(){\n  // Always call superconstructor first.\n  super();\n\n  // Initialize property values in the constructor.\n  this.adjective=\"awesome\";\n  this.level=11;\n}\n\n// Pass the properties used in the element's template to the `_render` function.\n_render({name, adjective}){\n  return html`\n    &lt;p&gt;This element is ${adjective} at an estimated level of ${level}.&lt;/p&gt;\n  `;\n}\n</code></pre>\n<p><strong>index.html</strong></p>\n<pre><code class=\"html language-html\">&lt;!-- Supply property values in markup --&gt;\n&lt;custom-element adjective=\"great\" level=\"10\"&gt;&lt;/custom-element&gt;\n\n&lt;!-- Or use the default property values set in the constructor --&gt;\n&lt;custom-element&gt;&lt;/custom-element&gt;\n</code></pre>","xbasicsintro":"<p><strong>custom-element.js</strong></p>\n<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xbindattributes":"<p>To bind a lit-element property to the attribute of another element: </p>\n<pre><code class=\"html language-html\">&lt;element attr$=${myProp}&gt;&lt;/element&gt;\n</code></pre>\n<p><strong>custom-element.js</strong></p>\n<pre><code class=\"js language-js\">class CustomElement extends LitElement {  \n  static get properties(){\n    return {\n      myStyle: String\n    };\n  }\n  constructor(){\n    super();\n    this.myStyle = '';\n  }\n  _render({myStyle}){\n    return html`\n      &lt;style&gt;\n        .red { color: red; }\n        .blue { color: blue; }\n      &lt;/style&gt;\n\n      &lt;p&gt;lit-element is &lt;span class$=\"${myStyle}\"&gt;rad&lt;/span&gt; :)&lt;/p&gt;\n    `;\n  }\n}\n</code></pre>\n<p><strong>index.html</strong></p>\n<pre><code class=\"html language-html\">&lt;custom-element myStyle=\"red\"&gt;&lt;/custom-element&gt;\n&lt;custom-element myStyle=\"blue\"&gt;&lt;/custom-element&gt;\n</code></pre>","xbindbooleans":"<p>In <code>custom-element.js</code>, inside a tagged JavaScript template literal: </p>\n<pre><code class=\"html language-html\">&lt;element hidden?=${myProp}&gt;&lt;/element&gt;\n</code></pre>\n<p>In markup: </p>\n<pre><code class=\"html language-html\">&lt;custom-element myProp=\"true\"&gt;&lt;/custom-element&gt;\n</code></pre>\n<p><strong>custom-element.js</strong></p>\n<pre><code class=\"js language-js\">class CustomElement extends LitElement {  \n  static get properties(){\n    return {\n      hideTextarea: Boolean\n    };\n  }\n  constructor(){\n    super();\n    this.hideTextarea = false;\n  }\n  _render({hideTextarea}){\n    return html`\n      &lt;p&gt;I have a textarea. It might be hidden.&lt;/p&gt;\n      &lt;textarea hidden?=${hideTextarea}&gt;Nope, not hidden right now.&lt;/textarea&gt;\n    `;\n  }\n}\n</code></pre>\n<p><strong>index.html</strong></p>\n<pre><code class=\"html language-html\">&lt;custom-element hideTextarea&gt;&lt;/custom-element&gt;\n&lt;br/&gt;\n&lt;custom-element&gt;&lt;/custom-element&gt;\n</code></pre>\n<p><em>Avoid these pitfalls. They won't do what they're intended to do:</em></p>\n<pre><code class=\"html language-html\">&lt;!-- \n  don't do this: \n  &lt;custom-element hideTextarea=\"false\"&gt;&lt;/custom-element&gt;\n\n  or this:\n  &lt;custom-element hideTextarea=false&gt;&lt;/custom-element&gt;\n--&gt;\n</code></pre>","xbindprops":"<p>Basic syntax inside a tagged JavaScript template literal is:</p>\n<pre><code class=\"html language-html\">&lt;element prop=\"${myProp}\"&gt;&lt;element&gt; \n</code></pre>\n<p>In your custom element class, do:</p>\n<pre><code class=\"js language-js\">_render({myProp}){\n  return html`\n    &lt;img src=\"${myProp}\" alt=\"Helpful alt text\"&gt;&lt;/src&gt;\n  `;\n}\n</code></pre>\n<p>In HTML, do:</p>\n<pre><code class=\"html language-html\">&lt;custom-element myProp=\"value of myProp\"&gt;&lt;/custom-element&gt;\n</code></pre>\n<p>Note that lit-element <strong>does not</strong> transform <code>camelCase</code> properties to\n<code>dash-case</code>. </p>\n<p><strong>custom-element.js</strong></p>\n<pre><code class=\"js language-js\">// Define your element's properties.\nstatic get properties(){\n  return {\n    url: String,\n    altText: String,\n    imgWidth: Number\n  };\n}\n// Initialize property values in the constructor.\nconstructor(){\n  // Always call superconstructor first.\n  super();\n\n  this.url=\"https://thecatapi.com/api/images/get?id=eb9\";\n  this.altText=\"A cat poking its head out from under some bedding.\";\n  this.imgWidth=500;\n}\n// Define your element's HTML template.\n_render({url, altText, imgWidth}){\n  return html`\n    &lt;img src=\"${url}\" alt=\"${altText}\" width=\"${imgWidth}\"&gt;&lt;/img&gt;\n  `;\n}\n</code></pre>\n<p><strong>index.html</strong></p>\n<pre><code class=\"html language-html\">&lt;custom-element\n  url=\"https://thecatapi.com/api/images/get?id=4of\"\n  altText=\"A gif of an adult cheetah popping her head up from a bunch of\n  cheetah cubs.\"&gt;\n&lt;/custom-element&gt;\n</code></pre>","xcreateelement":"<ul>\n<li><a href=\"#writeyourcustomelementclass\">Write your custom element class</a>.</li>\n<li><a href=\"#useyourcustomelementinanhtmldocument\">Use your custom element in an HTML document</a>.</li>\n</ul>\n<h2 id=\"writeyourcustomelementclass\">Write your custom element class</h2>\n<ul>\n<li>Import the <code>LitElement</code> base class and the <code>html</code> helper function. </li>\n<li>Extend the <code>LitElement</code> base class to create a class for your new custom\nelement.</li>\n<li>Define your element's properties.</li>\n<li>Define your element's template.</li>\n<li>Register the custom element with the browser.</li>\n</ul>\n<p><strong>custom-element.js</strong></p>\n<pre><code class=\"js language-js\">// Import the lit-element base class and the html helper function.\nimport { LitElement, html } from '@polymer/lit-element';\n\n// Extend the LitElement base class to create a class for your element.\nclass CustomElement extends LitElement {  \n\n  // Define your element's properties.\n  static get properties(){\n    return {\n      name: String\n    };\n  }\n\n  // Define your element's HTML template.\n  _render({name}){\n    // Use the html helper function to return a lit-html TemplateResult.\n    return html`\n      &lt;h1&gt;Hello ${name}!&lt;/h1&gt;\n    `;\n  }\n}\n\n// Register your element with the browser.\ncustomElements.define('custom-element', CustomElement);\n</code></pre>\n<h2 id=\"useyourcustomelementinanhtmldocument\">Use your custom element in an HTML document</h2>\n<p>Import and use your custom element in an HTML document. Include the\n<a href=\"https://github.com/webcomponents/webcomponentsjs\">WebComponents polyfills</a> for browser compatibility.</p>\n<p><strong>index.html</strong></p>\n<pre><code class=\"html language-html\">&lt;head&gt;\n  &lt;!-- Include polyfills for browser compatibility. --&gt;\n  &lt;script src=\"path/to/webcomponents-bundle.js\"&gt;&lt;/script&gt;\n  &lt;!-- Import your custom element. Note that the script tag's \"type\"\n       property must be \"module\". --&gt;\n  &lt;script type=\"module\" src=\"./custom-element.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;!-- Use your custom element in markup. --&gt;\n  &lt;custom-element name=\"World\"&gt;&lt;/custom-element&gt;\n&lt;/body&gt;\n</code></pre>","xcreateprops":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xcreateroot":"<p>Implement lit-element's <code>_createRoot</code> function to specify where to render your element's template.</p>\n<ul>\n<li><a href=\"#createashadowrootandrenderintoit\">Create a shadow-root and render into it</a> </li>\n<li><a href=\"#rendertoyourcustomelementschildreninlightdom\">Render to your custom element's children in light DOM</a></li>\n<li><a href=\"#renderintosomeothernode\">Render into some other node</a></li>\n</ul>\n<h2 id=\"createashadowrootandrenderintoit\">Create a shadow root and render into it</h2>\n<p>By default, lit-element creates a shadow root and renders your template into it, producing a DOM tree like this:</p>\n<pre><code class=\"html language-html\">&lt;custom-element-default&gt;\n  #shadow-root\n    &lt;h1&gt;Hi&lt;/h1&gt;\n&lt;/custom-element-default&gt;\n</code></pre>\n<p>To produce the DOM tree above:</p>\n<p><strong>custom-element-default.js</strong></p>\n<pre><code class=\"js language-js\">class CustomElementDefault extends LitElement {  \n  _render(){\n    return html`\n      &lt;h1&gt;hi&lt;/h1&gt;\n    `;\n  }\n}\n</code></pre>\n<p><strong>index.html</strong> </p>\n<pre><code class=\"html language-html\">&lt;custom-element-default&gt;&lt;/custom-element-default&gt;\n</code></pre>\n<h2 id=\"rendertoyourcustomelementschildreninlightdom\">Render to your custom element's children in light DOM</h2>\n<p>You can avoid creating shadow DOM and render directly into your element's children in light DOM. To produce the following DOM tree:</p>\n<pre><code class=\"html language-html\">&lt;custom-element-this&gt;\n  &lt;h1&gt;Hi&lt;/h1&gt;\n&lt;/custom-element-this&gt;\n</code></pre>\n<p>Return the custom element instance (<code>this</code>) from <code>_createRoot</code>:</p>\n<p><strong>custom-element-this.js</strong></p>\n<pre><code class=\"js language-js\">class CustomElementThis extends LitElement {  \n  _createRoot(){\n    return this;\n  }\n  _render(){\n    return html`\n      &lt;h1&gt;hi&lt;/h1&gt;\n    `;\n  }\n}\n</code></pre>\n<p><strong>index.html</strong> </p>\n<pre><code class=\"html language-html\">&lt;custom-element-this&gt;&lt;/custom-element-this&gt;\n</code></pre>\n<h2 id=\"renderintosomeothernode\">Render into some other node</h2>\n<p>To render into the light DOM of some other node, return that node from <code>_createRoot</code>. For example, in the following DOM tree, the lit-element node is empty, and its template has been rendered into a div element:</p>\n<pre><code class=\"html language-html\">&lt;div id=\"mydiv\"&gt;\n  &lt;h1&gt;Hi&lt;/h1&gt;\n&lt;/div&gt;\n&lt;custom-element-mydiv&gt;&lt;/custom-element-mydiv&gt;\n</code></pre>\n<p>To produce the DOM tree above, return the div element with <code>id=\"mydiv\"</code> from <code>_createRoot</code>:</p>\n<p><strong>custom-element-mydiv.js</strong></p>\n<pre><code class=\"js language-js\">class CustomElementMydiv extends LitElement {  \n  _createRoot(){\n    return document.getElementById('mydiv');\n  }\n  _render(){\n    return html`\n      &lt;h1&gt;hi&lt;/h1&gt;\n    `;\n  }\n}\n</code></pre>\n<p><strong>index.html</strong> </p>\n<pre><code class=\"html language-html\">&lt;div id=\"mydiv\"&gt;&lt;/div&gt;\n&lt;custom-element-mydiv&gt;&lt;/custom-element-mydiv&gt;\n</code></pre>","xdatabinding":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xdeclareprops":"<ul>\n<li><a href=\"#declareandinitializeproperties\">Declare and initialize properties</a>.</li>\n<li><a href=\"#bindpropertiestootherelements\">Bind properties to other elements</a>:<ul>\n<li><a href=\"#stringsandnumbers\">Strings and numbers</a>.</li>\n<li><a href=\"#booleans\">Booleans</a>.</li></ul></li>\n</ul>\n<h2 id=\"declareandinitializeproperties\">Declare and initialize properties</h2>\n<p><strong><code>custom-element.js</code></strong></p>\n<pre><code class=\"js language-js\">...\n  // Define your element's properties.\n  static get properties(){\n    return {\n      adjective: String,\n      level: Number\n    };\n  }\n  // Initialize properties in the constructor.\n  constructor(){\n    // Always call superconstructor first.\n    super();\n    this.adjective=\"awesome\";\n    this.level=11;\n  }\n\n  // Define your element's HTML template.\n  _render({name, adjective}){\n    return html`\n      &lt;p&gt;This element is ${adjective} at an estimated level of ${level}.&lt;/p&gt;\n    `;\n  }\n}\n...\n</code></pre>\n<p><strong><code>index.html</code></strong></p>\n<pre><code class=\"html language-html\">&lt;!-- Use the property values in the constructor --&gt;\n&lt;custom-element&gt;&lt;/custom-element&gt;\n\n&lt;!-- Or supply property values in markup --&gt;\n&lt;custom-element adjective=\"great\" level=\"10\"&gt;&lt;/custom-element&gt;\n</code></pre>\n<h2 id=\"bindpropertiestootherelements\">Bind properties to other elements</h2>\n<h3 id=\"stringsandnumbers\">Strings and numbers</h3>\n<p><strong><code>cat-api-wrapper.js</code></strong></p>\n<pre><code class=\"js language-js\">...\n  // Define your element's properties.\n  static get properties(){\n    return {\n      url: String,\n      altText: String,\n      imgWidth: Number\n    };\n  }\n  // Initialize property values in the constructor.\n  constructor(){\n    // Always call superconstructor first.\n    super();\n\n    this.url=\"http://thecatapi.com/?id=eb9\";\n    this.altText=\"A cat poking its head out from under some bedding.\";\n    this.imgWidth=500;\n  }\n  // Define your element's HTML template.\n  _render({url, altText, imgWidth}){\n    return html`\n      &lt;img src=\"${url}\" alt=\"${altText}\" width=\"${imgWidth}\"&gt;&lt;/img&gt;\n    `;\n  }\n...\n</code></pre>\n<p><strong><code>index.html</code></strong></p>\n<pre><code class=\"html language-html\">  &lt;!-- You can supply some properties and skip others --&gt;\n  &lt;cat-api-wrapper\n    url=\"http://thecatapi.com/?id=4of\" \n    altText=\"A gif of an adult cheetah popping her head up from a bunch of cheetah cubs.\"\n  &gt;\n  &lt;/cat-api-wrapper&gt;\n</code></pre>\n<h3 id=\"booleans\">Booleans</h3>","xdidrender":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xeventlisteners":"<ul>\n<li><a href=\"#basicexamples\">Basic examples</a></li>\n<li><a href=\"#passarbitraryvaluestoaneventhandler\">Pass arbitrary values to an event handler</a></li>\n</ul>\n<h2 id=\"basicexamples\">Basic examples</h2>\n<p>To add an event handler to a lit-element template, use an <code>on-event</code> annotation. We'll use the <code>click</code> event to illustrate.</p>\n<pre><code class=\"html language-html\">&lt;button on-click=\"${(event) =&gt; { /* do something with event */ }\"&gt;Click me&lt;/button&gt;\n</code></pre>\n<p>You can call a function in your element's class:</p>\n<pre><code class=\"html language-html\">&lt;button on-click=\"${(event) =&gt; {this.myFunc(event)}}\"&gt;Click me&lt;/button&gt;\n</code></pre>\n<p><strong>custom-element.js</strong></p>\n<pre><code class=\"js language-js\">class CustomElement extends LitElement {\n  _render({}) {\n    return html`\n      &lt;button \n        on-click=\"${(event) =&gt; {console.log(event)}}\"&gt;\n        Log a mouseClick event to the console.\n      &lt;/button&gt;\n\n      &lt;button \n        value=\"i &lt;3 lit-element\" \n        on-click=\"${(event) =&gt; {this.myFunc(event)}}\"&gt;\n        Do an alert.\n      &lt;/button&gt;\n    `;\n  }\n  myFunc(event) {\n    alert(event.target.value);\n  }\n}\n</code></pre>\n<h2 id=\"passarbitraryvaluestoaneventhandler\">Pass arbitrary values to an event handler</h2>\n<p>You can pass arbitrary values to an event handler:</p>\n<pre><code class=\"js language-js\">on-click=\"${(e) =&gt; someFunc(e, param1, param2)}\"\n</code></pre>\n<p><strong>custom-element.js</strong></p>\n<pre><code class=\"js language-js\">class CustomElement extends LitElement {\n  static get properties(){\n    return {\n      adjective: String\n    };\n  }\n\n  constructor(){\n    super();\n    this.adjective=\"awesome\";\n  }\n\n  _render({adjective}) {\n    return html`\n      &lt;button \n        value=\"World\" \n        on-click=\"${(event) =&gt; {this.inform(event.target.value, adjective, 11)}}\"&gt;\n        Inform me of something important.\n      &lt;/button&gt;\n    `;\n  }\n\n  inform(entity, adjective, level) {\n    var information = \n      'Hello, ' + entity + '!' +\n      'This element is ' + adjective +\n      ' at an approximate level of ' + level + '.';\n    console.log(information);\n    alert(information);\n  }\n}\n</code></pre>","xeventlisteners_":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xeventsintro":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xexpressions":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xfire":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xfirstrender":"<p>To perform one-time actions after your element has first rendered, implement lit-element's <code>_firstRendered</code> callback.</p>\n<pre><code class=\"js language-js\">import { LitElement, html } from '@polymer/lit-element';\n\nclass CustomElement extends LitElement {  \n  static get properties(){\n    return {\n      stuff: String\n    };\n  }\n  constructor(){\n    super();\n    this.stuff='Hi';\n  }\n  _render({stuff}){\n    return html`\n      &lt;p&gt;${stuff}&lt;/p&gt;\n    `;\n  }\n  _firstRendered(){\n    console.log(this.stuff);\n  }\n}\n\ncustomElements.define('custom-element', CustomElement);\n</code></pre>","xhandle":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xlocalsetup":"<ul>\n<li><a href=\"#installprerequisites\">Install pre-requisites</a></li>\n<li><a href=\"#downloadandservethestartlitsampleproject\">Download and serve the start-lit sample project</a></li>\n<li><a href=\"#buildthestartlitsampleprojectforproduction\">Build the start-lit sample project for production</a></li>\n</ul>\n<h2 id=\"installprerequisites\">Install pre-requisites</h2>\n<ol>\n<li><p><a href=\"https://git-scm.com/\">Install Git</a>.</p></li>\n<li><p><a href=\"https://nodejs.org/en/\">Install npm and Node.js</a>.</p></li>\n<li><p>Update npm:</p>\n<pre><code class=\"bash language-bash\">npm install -g npm@latest\n</code></pre></li>\n<li><p>Install Polymer CLI: </p>\n<pre><code class=\"bash language-bash\">npm install -g polymer-cli@latest\n</code></pre></li>\n</ol>\n<h2 id=\"downloadandservethestartlitsampleproject\">Download and serve the start-lit sample project</h2>\n<ol>\n<li><p>Use Git to copy a sample project:</p>\n<pre><code class=\"bash language-bash\">git clone https://github.com/katejeffreys/start-lit.git\n</code></pre></li>\n<li><p>Go to the <code>start-lit</code> folder:</p>\n<pre><code class=\"bash language-bash\">cd start-lit\n</code></pre></li>\n<li><p>Install the project's dependencies: </p>\n<pre><code class=\"bash language-bash\">npm install\n</code></pre></li>\n<li><p>Serve the project locally:</p>\n<pre><code class=\"bash language-bash\">polymer serve\n</code></pre></li>\n</ol>\n<h2 id=\"buildthestartlitsampleprojectforproduction\">Build the start-lit sample project for production</h2>\n<p>lit-element code needs a few changes for web browsers to load it. During developent, the Polymer CLI development server (<code>polymer serve</code>) handles this for you.</p>\n<p>To deploy a lit-element project to the web, you need to build it. Configure build options in <code>polymer.json</code>, then run <code>polymer build</code>.</p>\n<p>We've included a sample polymer.json file to get you up and running.</p>\n<p>See the <a href=\"https://www.polymer-project.org/3.0/docs/tools/polymer-cli\">Polymr CLI documentation</a> for more info.</p>\n<p><strong>To build the start-lit sample project:</strong></p>\n<ol>\n<li><p>Go to your root project folder:</p>\n<pre><code class=\"bash language-bash\">cd start-lit\n</code></pre></li>\n<li><p>Use Polymer CLI to build your project:</p>\n<pre><code class=\"bash language-bash\">polymer build\n</code></pre></li>\n</ol>","xobjects":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xobservechanges":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xpoly":"<h2 id=\"creatingatemplate\">Creating a template</h2>\n<h3 id=\"polymer30\">Polymer 3.0</h3>\n<pre><code class=\"js language-js\">static get template (){\n  return html`\n    &lt;h1&gt;[[prop]]&lt;/h1&gt;\n  `;\n}\n</code></pre>\n<h3 id=\"litelement\">lit-element</h3>\n<pre><code class=\"js language-js\">_render({prop}){\n  return html`\n    &lt;h1&gt;${prop}&lt;/h1&gt;\n  `;\n}\n</code></pre>\n<h2 id=\"defineandinitializeprops\">Define and initialize props</h2>\n<h3 id=\"polymer30-1\">Polymer 3.0</h3>\n<pre><code class=\"js language-js\">static get properties(){\n  return {\n    prop: {\n      type: String,\n      value: 'hi'\n    },\n    obj: {\n      type: Object,\n      value: function(){return {subProp1: 'value', subProp2: 'value'};}\n    }\n  };\n}\n</code></pre>\n<h3 id=\"litelement-1\">lit-element</h3>\n<pre><code class=\"js language-js\">static get properties(){\n  return {\n    prop: String,\n    obj: Object\n  }\n}\nconstructor(){\n  super();\n  this.prop='hi';\n  this.obj=Object.assign({subProp1: 'value', subProp2: 'value'});\n}\n</code></pre>\n<h2 id=\"onewaydatabindingproperties\">One-way data binding: Properties</h2>\n<h3 id=\"polymer30-2\">Polymer 3.0</h3>\n<pre><code class=\"js language-js\">static get template(){\n  return html`\n    &lt;button value=\"[[prop]]\"&gt;&lt;/button&gt;\n  `;\n}\n</code></pre>\n<h3 id=\"litelement-2\">lit-element</h3>\n<pre><code class=\"js language-js\">_render({prop}){\n  return html`\n    &lt;button value=\"${prop}\"&gt;&lt;/button&gt;\n  `;\n}\n</code></pre>\n<h2 id=\"onewaydatabindingattributes\">One-way data binding: Attributes</h2>\n<h3 id=\"polymer30-3\">Polymer 3.0</h3>\n<pre><code class=\"js language-js\">static get template(){\n  return html`\n    &lt;a href$=\"[[prop]]\"&gt;&lt;/a&gt;\n  `;\n}\n</code></pre>\n<h3 id=\"litelement-3\">lit-element</h3>\n<pre><code class=\"js language-js\">_render({prop}){\n  return html`\n    &lt;a href$=\"${prop}\"&gt;&lt;/a&gt;\n  `;\n}\n</code></pre>\n<h2 id=\"addeventlistenersinatemplate\">Add event listeners in a template</h2>\n<h3 id=\"polymer30-4\">Polymer 3.0</h3>\n<pre><code class=\"js language-js\">static get template(){\n  return html`\n    &lt;button on-click=\"myFunc\"&gt;&lt;/button&gt;\n  `;\n}\nmyFunc(e){\n  // do stuff\n}\n</code></pre>\n<h3 id=\"litelement-4\">lit-element</h3>\n<pre><code class=\"js language-js\">_render({props}){\n  return html`\n    &lt;button on-click=\"${(e) =&gt; this.myFunc(e, props)}\"&gt;&lt;/button&gt;\n  `;\n}\nmyFunc(e, props){\n  // do stuff\n}\n</code></pre>\n<h2 id=\"twowaydatabinding\">Two-way data binding</h2>\n<h3 id=\"polymer30-5\">Polymer 3.0</h3>\n<p>Two-way data binding is possible with <code>{{prop}}</code> annotations and props that notify upwards.</p>\n<p>parent-element.js</p>\n<pre><code class=\"js language-js\">import './child-element.js';\n\nclass ParentElement extends PolymerElement {\n  static get properties(){\n    return {\n      pProp: String\n      // This prop will reflect changes made in child-element\n    }\n  }\n\n  static get template(){\n    return html`\n      &lt;child-element cProp=\"{{pProp}}\"&gt;&lt;/child-element&gt;\n    `;\n  }\n}\n</code></pre>\n<p>child-element.js</p>\n<pre><code class=\"js language-js\">class ParentElement extends PolymerElement {\n\n  static get properties(){\n    return {\n      cProp: {\n        type: String,\n        notify: true\n      }\n    };\n  }\n  static get template(){\n    return html`\n      [[cProp]]\n    `;\n  }\n  ...\n  changeProp(){\n    // cProp changes here\n    // pProp changes in response\n  }\n}\n</code></pre>\n<h3 id=\"litelement-5\">lit-element</h3>\n<p>For performance, there is no two-way data binding. One way to do it is \"props down, events up\":</p>\n<p>parent-element.js</p>\n<pre><code class=\"js language-js\">import './child-element.js';\n\nclass ParentElement extends LitElement {\n  static get properties(){\n    return {\n      pProp: String\n    }\n  }\n  _render({pProp}){\n    return html`\n      &lt;child-element \n        on-some-event=\"${(e) =&gt; this.doStuff(e)}\" \n        cProp=\"${pProp}\"&gt;\n      &lt;/child-element&gt;\n    `;\n  }\n  doStuff(e){\n    this.pProp = e.detail.newVal;\n  }\n}\n</code></pre>\n<p>child-element.js</p>\n<pre><code class=\"js language-js\">class ChildElement extends LitElement {\n  static get properties(){\n    return {\n      cProp: String\n    }\n  }\n  _render({cProp}){\n    return html`\n      ${cProp}\n    `;\n  }\n  changeProp(){\n    // cProp changes here\n    this.dispatchEvent(new CustomEvent('some-event', detail: {\n      newVal: this.cProp}\n    ));\n  }\n}\n</code></pre>\n<p>Another way to do it is to implement state management like Redux and have components dispatch requests to update the same store.</p>\n<h2 id=\"observers\">Observers</h2>\n<h3 id=\"polymer30-6\">Polymer 3.0</h3>\n<pre><code class=\"js language-js\">static get properties(){\n  return {\n    cProp: {\n      type: String,\n      observer: \"myObserver\"\n    }\n  }\n}\nmyObserver(newVal, oldVal){\n  // do stuff\n}\n</code></pre>\n<h3 id=\"litelement-6\">lit-element</h3>\n<ul>\n<li>Props declared in <code>properties</code> getter are automatically observed. </li>\n<li>No observers for individual paths or props.</li>\n<li>By default, <code>_render</code> will fire when any of the props declared in <code>properties</code> changes.</li>\n<li>After a prop change, you can access new and old prop values in <code>_shouldRender</code> (before next render) or <code>_didRender</code> (after next render).</li>\n</ul>\n<pre><code class=\"js language-js\">static get properties(){\n  return {\n    prop: String\n  }\n}\n_didRender(oldVals, changedProps, newVals){\n  if(changedProps.prop){\n    // do stuff\n  }\n}\n</code></pre>\n<h2 id=\"complexprops\">Complex props</h2>\n<h3 id=\"polymer30-7\">Polymer 3.0</h3>\n<pre><code class=\"js language-js\">static get properties(){\n  return {\n    cProp: {\n      type: Object,\n      value: function(){return{subProp: 'value'};}\n    }\n  }\n}\nstatic get observers(){\n  return [\"myFunc(cProp.*)\"];\n}\nmyFunc(changes){\n  // do stuff with changes.path\n  // do stuff with changes.value\n}\n</code></pre>\n<h3 id=\"litelement-7\">lit-element</h3>\n<pre><code class=\"js language-js\">static get properties(){\n  return {\n    cProp: Object\n  }\n}\n_shouldRender(newVals, changedProps, oldVals){\n  // Only fires on object reassignment\n  // No subprop observation\n}\n</code></pre>\n<h2 id=\"conditionals\">Conditionals</h2>\n<h3 id=\"polymer30-8\">Polymer 3.0</h3>\n<pre><code class=\"js language-js\">static get properties(){\n  return {\n    cProp: {\n      type: Object,\n      value: function(){return{subProp: 'value'};}\n    }\n  }\n}\nstatic get observers(){\n  return [\"myFunc(cProp.*)\"];\n}\nmyFunc(changes){\n  // do stuff with changes.path\n  // do stuff with changes.value\n}\n</code></pre>\n<h3 id=\"litelement-8\">lit-element</h3>\n<pre><code class=\"js language-js\">static get properties(){\n  return {\n    cProp: Object\n  }\n}\n_shouldRender(newVals, changedProps, oldVals){\n  // Only fires on object reassignment\n  // No subprop observation\n}\n</code></pre>","xpolycomplexdata":"<h2 id=\"polymer30\">Polymer 3.0</h2>\n<pre><code class=\"js language-js\">static get properties(){\n  return {\n    cProp: {\n      type: Object,\n      value: function(){return{subProp: 'value'};}\n    }\n  }\n}\nstatic get observers(){\n  return [\"myFunc(cProp.*)\"];\n}\nmyFunc(changes){\n  // do stuff with changes.path\n  // do stuff with changes.value\n}\n</code></pre>\n<h2 id=\"litelement\">lit-element</h2>\n<pre><code class=\"js language-js\">static get properties(){\n  return {\n    cProp: Object\n  }\n}\n_shouldRender(newVals, changedProps, oldVals){\n  // Only fires on object reassignment\n  // No subprop observation\n}\n</code></pre>","xpolyconditional":"<ul>\n<li><a href=\"#\">Polymer 3.0</a>: <code>&lt;dom-if&gt;</code></li>\n<li><a href=\"#\">lit-element</a>: Expressions</li>\n</ul>\n<h2 id=\"polymer30\">Polymer 3.0</h2>\n<pre><code class=\"js language-js\">import '@polymer/polymer/lib/elements/dom-if.html';\n\nclass CustomElement extends PolymerElement{\n  static get properties(){\n    return {\n      myBool: Boolean\n    }\n  }\n  constructor(){\n    super();\n    this.myBool=false;\n  }\n  static get template(){\n    return html`\n      &lt;p&gt;Template stuff here&lt;/p&gt;\n      &lt;template is=\"dom-if\" if=\"[[myBool]]\"&gt;\n        &lt;p&gt;Display this only when myBool is true&lt;/p&gt;\n      &lt;/template&gt;\n      &lt;p&gt;More template stuff here&lt;/p&gt;\n    `;\n  }\n}\n</code></pre>\n<h3 id=\"litelement\">lit-element</h3>\n<pre><code class=\"js language-js\">class CustomElement extends LitElement{\n  static get properties(){\n    return {\n      myBool: Boolean\n    }\n  }\n  constructor(){\n    super();\n    this.myBool=false;\n  }\n  _render({myBool}){\n    return html`\n      &lt;p&gt;Template stuff here&lt;/p&gt;\n      ${myBool?html`&lt;p&gt;Display this only when myBool is true&lt;/p&gt;`:''}\n      &lt;p&gt;More template stuff here&lt;/p&gt;\n    `;\n  }\n}\n</code></pre>","xpolycreateprops":"<h2 id=\"polymer30\">Polymer 3.0</h2>\n<pre><code class=\"js language-js\">static get properties(){\n  return {\n    prop: {\n      type: String,\n      value: 'hi'\n    },\n    obj: {\n      type: Object,\n      value: function(){return {subProp1: 'value', subProp2: 'value'};}\n    }\n  };\n}\n</code></pre>\n<h2 id=\"litelement\">lit-element</h2>\n<pre><code class=\"js language-js\">static get properties(){\n  return {\n    prop: String,\n    obj: Object\n  }\n}\nconstructor(){\n  super();\n  this.prop='hi';\n  this.obj=Object.assign({subProp1: 'value', subProp2: 'value'});\n}\n</code></pre>","xpolydeclevent":"<h2 id=\"polymer30\">Polymer 3.0</h2>\n<pre><code class=\"js language-js\">static get template(){\n  return html`\n    &lt;button on-click=\"myFunc\"&gt;&lt;/button&gt;\n  `;\n}\nmyFunc(e){\n  // do stuff\n}\n</code></pre>\n<h2 id=\"litelement\">lit-element</h2>\n<pre><code class=\"js language-js\">_render({props}){\n  return html`\n    &lt;button on-click=\"${(e) =&gt; this.myFunc(e, props)}\"&gt;&lt;/button&gt;\n  `;\n}\nmyFunc(e, props){\n  // do stuff\n}\n</code></pre>","xpolyiterate":"<ul>\n<li><a href=\"#\">Polymer 3.0</a>: <code>&lt;dom-repeat&gt;</code></li>\n<li><a href=\"#\">lit-element</a>: Expressions</li>\n</ul>\n<h2 id=\"polymer30\">Polymer 3.0</h2>\n<pre><code class=\"js language-js\">import '@polymer/polymer/lib/elements/dom-repeat.html';\n\nclass CustomElement extends PolymerElement{\n  static get properties(){\n    return {\n      myArray: Array\n    }\n  }\n  constructor(){\n    super();\n    this.myArray=['this', 'is', 'an', 'array'];\n  }\n  static get template(){\n    return html`\n      &lt;p&gt;Template stuff here&lt;/p&gt;\n      &lt;template is=\"dom-repeat\" items=\"[[myArray]]\"&gt;\n        &lt;p id=\"item[[index]]\"&gt;[[item]]&lt;/p&gt;\n      &lt;/template&gt;\n      &lt;p&gt;More template stuff here&lt;/p&gt;\n    `;\n  }\n}\n</code></pre>\n<h3 id=\"litelement\">lit-element</h3>\n<pre><code class=\"js language-js\">class CustomElement extends LitElement{\n  static get properties(){\n    return {\n      myArray: Array\n    }\n  }\n  constructor(){\n    super();\n    this.myArray=['this', 'is', 'an', 'array'];\n  }\n  _render({myArray}){\n    return html`\n      &lt;p&gt;Template stuff here&lt;/p&gt;\n      ${myArray.map((item, index) =&gt; `&lt;p id=\"item${index}\"&gt;${item}&lt;/p&gt;`);}\n      &lt;p&gt;More template stuff here&lt;/p&gt;\n    `;\n  }\n}\n</code></pre>","xpolymerintro":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xpolyobservers":"<h2 id=\"polymer30\">Polymer 3.0</h2>\n<pre><code class=\"js language-js\">static get properties(){\n  return {\n    cProp: {\n      type: String,\n      observer: \"myObserver\"\n    }\n  }\n}\nmyObserver(newVal, oldVal){\n  // do stuff\n}\n</code></pre>\n<h2 id=\"litelement\">lit-element</h2>\n<ul>\n<li>Props declared in <code>properties</code> getter are automatically observed. </li>\n<li>No observers for individual paths or props.</li>\n<li>By default, <code>_render</code> will fire when any of the props declared in <code>properties</code> changes.</li>\n<li>After a prop change, you can access new and old prop values in <code>_shouldRender</code> (before next render) or <code>_didRender</code> (after next render).</li>\n</ul>\n<pre><code class=\"js language-js\">static get properties(){\n  return {\n    prop: String\n  }\n}\n_didRender(oldVals, changedProps, newVals){\n  if(changedProps.prop){\n    // do stuff\n  }\n}\n</code></pre>","xpolyoneway":"<p>AKA one-way data binding.</p>\n<h2 id=\"polymer30\">Polymer 3.0</h2>\n<h3 id=\"properties\">Properties</h3>\n<pre><code class=\"js language-js\">static get template(){\n  return html`\n    &lt;button value=\"[[prop]]\"&gt;&lt;/button&gt;\n  `;\n}\n</code></pre>\n<h3 id=\"attributes\">Attributes</h3>\n<pre><code class=\"js language-js\">static get template(){\n  return html`\n    &lt;a href$=\"[[prop]]\"&gt;&lt;/a&gt;\n  `;\n}\n</code></pre>\n<h2 id=\"litelement\">lit-element</h2>\n<h3 id=\"properties-1\">Properties</h3>\n<pre><code class=\"js language-js\">_render({prop}){\n  return html`\n    &lt;button value=\"${prop}\"&gt;&lt;/button&gt;\n  `;\n}\n</code></pre>\n<h3 id=\"attributes-1\">Attributes</h3>\n<pre><code class=\"js language-js\">_render({prop}){\n  return html`\n    &lt;a href$=\"${prop}\"&gt;&lt;/a&gt;\n  `;\n}\n</code></pre>","xpolytemplate":"<h2 id=\"polymer30\">Polymer 3.0</h2>\n<pre><code class=\"js language-js\">static get template (){\n  return html`\n    &lt;h1&gt;[[prop]]&lt;/h1&gt;\n  `;\n}\n</code></pre>\n<h2 id=\"litelement\">lit-element</h2>\n<pre><code class=\"js language-js\">_render({prop}){\n  return html`\n    &lt;h1&gt;${prop}&lt;/h1&gt;\n  `;\n}\n</code></pre>","xpolytwoway":"<p>AKA two-way data binding.</p>\n<p>In Polymer, two-way data binding is possible. In lit-element, it is not.</p>\n<p><strong>Why not?</strong></p>\n<ul>\n<li>Performance</li>\n<li>Code legibility</li>\n<li>Better app design and state management paradigms exist</li>\n</ul>\n<h2 id=\"polymer30\">Polymer 3.0</h2>\n<p>Two-way data binding is possible with <code>{{prop}}</code> annotations and props that notify upwards.</p>\n<p>parent-element.js</p>\n<pre><code class=\"js language-js\">import './child-element.js';\n\nclass ParentElement extends PolymerElement {\n  static get properties(){\n    return {\n      pProp: String\n      // This prop will reflect changes made in child-element\n    }\n  }\n\n  static get template(){\n    return html`\n      &lt;child-element cProp=\"{{pProp}}\"&gt;&lt;/child-element&gt;\n    `;\n  }\n}\n</code></pre>\n<p>child-element.js</p>\n<pre><code class=\"js language-js\">class ParentElement extends PolymerElement {\n\n  static get properties(){\n    return {\n      cProp: {\n        type: String,\n        notify: true\n      }\n    };\n  }\n  static get template(){\n    return html`\n      [[cProp]]\n    `;\n  }\n  ...\n  changeProp(){\n    // cProp changes here\n    // pProp changes in response\n  }\n}\n</code></pre>\n<h2 id=\"litelement\">lit-element</h2>\n<h3 id=\"propsdowneventsup\">Props down, events up</h3>\n<p>One way to do it is \"props down, events up\":</p>\n<p>parent-element.js</p>\n<pre><code class=\"js language-js\">import './child-element.js';\n\nclass ParentElement extends LitElement {\n  static get properties(){\n    return {\n      pProp: String\n    }\n  }\n  _render({pProp}){\n    return html`\n      &lt;child-element \n        on-some-event=\"${(e) =&gt; this.doStuff(e)}\" \n        cProp=\"${pProp}\"&gt;\n      &lt;/child-element&gt;\n    `;\n  }\n  doStuff(e){\n    this.pProp = e.detail.newVal;\n  }\n}\n</code></pre>\n<p>child-element.js</p>\n<pre><code class=\"js language-js\">class ChildElement extends LitElement {\n  static get properties(){\n    return {\n      cProp: String\n    }\n  }\n  _render({cProp}){\n    return html`\n      ${cProp}\n    `;\n  }\n  changeProp(){\n    // cProp changes here\n    this.dispatchEvent(new CustomEvent('some-event', detail: {\n      newVal: this.cProp}\n    ));\n  }\n}\n</code></pre>\n<h3 id=\"statemanagement\">State management</h3>\n<p>Another way to do it is to implement state management like Redux and have components dispatch requests to update the same store.</p>","xpure":"<p>Given the same inputs, a <strong>pure function</strong> always returns the same outputs, and has no side effects.</p>\n<ul>\n<li><a href=\"#\">_render as a pure function of properties</a></li>\n<li><a href=\"#\">Avoid modifying DOM outside _render</a></li>\n<li><a href=\"#\">Remove side effects from _render</a></li>\n</ul>\n<h2 id=\"_renderasapurefunction\">_render as a pure function</h2>\n<p>A good practice for lit-element is to implement <code>_render</code> as a pure function. To do this:</p>\n<ul>\n<li>Describe your element's template only by implementing <code>_render</code> as a function of the element's own properties. </li>\n<li>Ensure that for the same property values, <code>_render</code> will always return the same TemplateResult.</li>\n<li>Do not create any side effects in <code>_render</code>.</li>\n</ul>\n<p><strong>Example</strong></p>\n<pre><code class=\"js language-js\">class CustomElement extends LitElement{\n  static get properties(){\n    return {\n      // Define the props that will be params for _render().\n    };\n  }\n  constructor(){\n    super();\n    // Initialize props. \n    // this.prop='';\n\n    // Create any event listeners on the custom element instance (`this`).\n    this.addEventListener(\n      'some-event', \n      async (e) =&gt; this.respondToSomeEvent(e)\n    );\n  }\n\n  respondToSomeEvent(e){\n    // Do some stuff\n    await this.renderComplete;\n    // Do some other stuff\n  }\n\n  _render({props}){\n    return html`\n      // Implement a pure function on props.\n    `;\n  }\n\n  _shouldRender(){\n    // Specify which changes should trigger _render().\n  }\n\n  /*\n   * ...\n   * \n   * Write your other functions here. You can change the values of props,\n   * but you should not manipulate DOM.\n   * \n   * ... \n   */\n  }\n}\n</code></pre>\n<h2 id=\"avoidmodifyingdomoutside_render\">Avoid modifying DOM outside _render</h2>\n<p><code>_render</code> modifies DOM efficiently by passing property values to element templates, such that only the values of the properties are rewritten.</p>\n<p>If you find that you need to make modifications to the DOM outside of <code>_render</code>, you have a few options:</p>\n<ul>\n<li><p>Rewrite your element to put the data in a prop so that it triggers <code>_render()</code> automatically. </p></li>\n<li><p>Consider splitting up your element into multiple elements - for example, split up UI logic into multiple app views, each in its own element. This may help simplify your <code>_render()</code> function for each one.</p></li>\n<li><p>Consider using Redux to help manage complex app state.</p></li>\n</ul>\n<h2 id=\"removesideeffectsfrom_render\">Remove side effects from _render()</h2>\n<p>Move anything unrelated to rendering out of <code>_render()</code>. For instance, if you need to do something directly before or after <code>_render()</code> is called, move the work to the relevant lifecycle callback.</p>","xrender":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xrendercomplete":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xrequestrender":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xshouldrender":"<p>By default, any change to a property declared in the <code>properties</code> getter will cause <code>_render</code> to fire.</p>\n<p>You can use the callback <code>_shouldRender</code> to override this behavior and specify which property changes cause an element to render.</p>\n<pre><code class=\"js language-js\">class CustomElement extends LitElement {\n  // declare props, etc\n  // ...\n\n  _render({prop1, prop2, prop3}){\n    return html`\n      ${prop1}\n      ${prop2}\n      ${prop3}\n    `;\n  }\n  /** \n   * _shouldRender(props, changedProps, prevProps)\n   * \n   * _shouldRender fires when props change. If it returns true, _render() fires.\n   * Default is that _shouldRender always returns true. \n   * \n   * Params:\n   * \n   * props: An object containing the current values of all of the element's\n   *    props, keyed by prop name.\n   * \n   * changedProps: An object containing the current values of all of the props \n   *    that have changed since they were last rendered, keyed by prop name.\n   * \n   * prevProps: An object containing the value that was last rendered for each \n   *    of the props in changedProps, keyed by prop name.\n   */\n  _shouldRender(props, changedProps, prevProps){\n    console.log('props are now: ', props);\n    console.log('props that changed: ', changedProps);\n    console.log('previous props were: ', prevProps);\n\n    // You can override _shouldRender if you need to specify which property\n    // changes should trigger a render. \n    // E.g. this can only return a truthy value if prop1 is in changedProps:\n    return changedProps.prop1;\n  }\n</code></pre>","xstatic":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xstyle":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xstyleintro":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xtemplate":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>","xtheme":"<pre><code class=\"js language-js\">_render(){\n  return html`\n    &lt;h1&gt;TEMPLATE&lt;/h1&gt;\n  `;\n}\n</code></pre>"}